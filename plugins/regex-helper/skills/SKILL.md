# regex-helper スキル

正規表現に関する作業を対話的にサポートするスキルです。

## このスキルを使うタイミング

以下のような会話・リクエストがあった場合、このスキルを使って対応してください：

### 正規表現を作りたい
- 「メールアドレスの正規表現を作って」
- 「電話番号を抽出したい」
- 「こういう文字列からこの部分を取りたい」
- 「〜にマッチする正規表現」
- 「〜を検証する正規表現」
- 「パスワードのバリデーション」

→ **対話型で作成**: 用途を確認 → 条件を1つずつ質問 → 生成 → テスト

### 正規表現を理解したい
- 「この正規表現の意味を教えて」
- 「/pattern/ を解説して」
- 「この正規表現は何をしている？」

→ **分解して解説**: 各部分の意味を説明 → 要約 → 用途を推測

### 正規表現をテストしたい
- 「この正規表現が動くか試したい」
- 「/pattern/ をテストして」
- 「〜にマッチするか確認」

→ **テスト実行**: テスト文字列を入力してもらう → 結果表示 → 繰り返しテスト可能

### 正規表現がうまく動かない
- 「正規表現がマッチしない」
- 「なぜこれが動かないの？」
- 「期待通りにマッチしない」

→ **デバッグ**: 正規表現とテスト文字列を確認 → 原因を特定 → 修正案を提示

### 置換をしたい
- 「正規表現で置換したい」
- 「〜を〜に変換したい」
- 「日付のフォーマットを変えたい」

→ **置換パターン作成**: 変換前後の例を確認 → 検索・置換パターン生成 → コード例提示

### 言語間で変換したい
- 「JavaScriptの正規表現をPythonで使いたい」
- 「この正規表現をGoに変換して」

→ **言語間変換**: 元の言語と正規表現を確認 → 変換先の言語を確認 → 変換結果とコード例

## 対話のガイドライン

### 作成時の対話フロー

1. **用途を確認**
   - 何を抽出/検証したいか
   - どのような文字列が対象か

2. **条件を1つずつ確認**（選択肢を提示して負担軽減）
   ```
   例: パスワード検証の場合
   - 最低文字数は？
   - 大文字は必須？
   - 数字は必須？
   - 記号は必須？
   ```

3. **サンプル文字列から推測**（ユーザーが例を示した場合）
   ```
   ユーザー: "ORD-12345-JP からこういうのを抽出したい"
   → パターンを分析: [英字3文字]-[数字5桁]-[英字2文字]
   → 正規表現を生成: /ORD-\d{5}-[A-Z]{2}/
   → 他のサンプルがあれば追加で確認（精度向上）
   ```

4. **結果を提示**
   ```
   生成した正規表現: /pattern/flags

   構造の説明:
   - 各部分の意味

   テストしますか？
   ```

5. **テスト＆調整**
   - マッチ結果を表示
   - マッチしない場合は理由を説明
   - 必要に応じて調整

6. **最終出力**
   - 正規表現
   - 用途の説明
   - コード例（JavaScript等）

### デバッグ時の対話フロー

1. 正規表現とテスト文字列を確認
2. 正規表現の各部分を順番に検証
3. どこで失敗しているかを特定
4. 原因を説明（専門用語は補足付き）
5. 修正案を複数提示

### 回答のポイント

- 専門用語を避け、わかりやすく説明
- 一度に多くの質問をしない
- 選択肢を提示して回答しやすく
- マッチしない場合は理由を説明
- 最後にコード例を添える

## スラッシュコマンド

より明示的に機能を呼び出す場合は以下のコマンドも使えます：

- `/regex-helper:build` - 対話型ビルダー
- `/regex-helper:explain` - 正規表現解説
- `/regex-helper:test` - テスター
- `/regex-helper:patterns` - パターン集
- `/regex-helper:replace` - 置換支援
- `/regex-helper:debug` - デバッグ
- `/regex-helper:convert` - 言語間変換

---

## 正規表現の基礎知識

### メタ文字

| 文字 | 意味 | 例 |
|------|------|-----|
| `.` | 任意の1文字（改行除く） | `a.c` → "abc", "a1c" |
| `*` | 直前を0回以上繰り返し | `ab*c` → "ac", "abc", "abbc" |
| `+` | 直前を1回以上繰り返し | `ab+c` → "abc", "abbc" |
| `?` | 直前を0回または1回 | `ab?c` → "ac", "abc" |
| `^` | 文字列/行の先頭 | `^abc` → 先頭の"abc" |
| `$` | 文字列/行の末尾 | `abc$` → 末尾の"abc" |
| `\|` | OR（いずれか） | `cat\|dog` → "cat" or "dog" |
| `()` | グループ化 | `(ab)+` → "ab", "abab" |
| `[]` | 文字クラス | `[aeiou]` → 母音1文字 |
| `{}` | 量指定子 | `a{2,4}` → "aa", "aaa", "aaaa" |

### 文字クラス

| パターン | 意味 | 同等の表現 |
|----------|------|-----------|
| `\d` | 数字 | `[0-9]` |
| `\D` | 数字以外 | `[^0-9]` |
| `\w` | 単語文字 | `[A-Za-z0-9_]` |
| `\W` | 単語文字以外 | `[^A-Za-z0-9_]` |
| `\s` | 空白文字 | `[ \t\n\r\f\v]` |
| `\S` | 空白以外 | `[^ \t\n\r\f\v]` |
| `\b` | 単語境界 | - |
| `\B` | 単語境界以外 | - |

### 量指定子

| パターン | 意味 | 貪欲/非貪欲 |
|----------|------|-------------|
| `*` | 0回以上 | 貪欲 |
| `+` | 1回以上 | 貪欲 |
| `?` | 0回または1回 | 貪欲 |
| `{n}` | ちょうどn回 | - |
| `{n,}` | n回以上 | 貪欲 |
| `{n,m}` | n回以上m回以下 | 貪欲 |
| `*?` | 0回以上 | 非貪欲 |
| `+?` | 1回以上 | 非貪欲 |
| `??` | 0回または1回 | 非貪欲 |
| `{n,m}?` | n回以上m回以下 | 非貪欲 |

### アサーション（先読み・後読み）

| パターン | 名前 | 意味 |
|----------|------|------|
| `(?=...)` | 肯定先読み | 後ろに...が続く位置 |
| `(?!...)` | 否定先読み | 後ろに...が続かない位置 |
| `(?<=...)` | 肯定後読み | 前に...がある位置 |
| `(?<!...)` | 否定後読み | 前に...がない位置 |

## ベストプラクティス

### 1. 可読性を重視する

```
悪い例: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$

良い例（コメント付き、xフラグ使用）:
/
  ^                 # 先頭
  (?=.*[A-Z])       # 大文字を含む
  (?=.*[a-z])       # 小文字を含む
  (?=.*\d)          # 数字を含む
  (?=.*[@$!%*?&])   # 記号を含む
  [A-Za-z\d@$!%*?&]{8,}  # 8文字以上
  $                 # 末尾
/x
```

### 2. 過度に複雑にしない

1つの正規表現で全てを解決しようとせず、複数のシンプルな正規表現に分割することを検討:

```javascript
// 悪い例: 1つの複雑な正規表現
const isValid = /^(?=.*[A-Z])(?=.*\d).{8,}$/.test(password);

// 良い例: 分割してチェック
const hasUppercase = /[A-Z]/.test(password);
const hasDigit = /\d/.test(password);
const hasMinLength = password.length >= 8;
const isValid = hasUppercase && hasDigit && hasMinLength;
```

### 3. パフォーマンスに注意

- 壊滅的バックトラッキングを避ける
- `.*` の多用を避ける
- 可能なら非キャプチャグループ `(?:...)` を使用

```
危険なパターン: /(a+)+b/  ← 壊滅的バックトラッキングの可能性
安全なパターン: /a+b/
```

### 4. 入力の検証には厳密に

ユーザー入力を検証する場合は、`^` と `$` でアンカーする:

```javascript
// 悪い例: 部分マッチを許容
/\d{3}-\d{4}/.test("abc123-4567xyz"); // true

// 良い例: 完全マッチを要求
/^\d{3}-\d{4}$/.test("abc123-4567xyz"); // false
/^\d{3}-\d{4}$/.test("123-4567"); // true
```

### 5. 言語固有の機能を理解する

各言語で正規表現の挙動が異なる場合がある:

- JavaScript: Unicode対応には `u` フラグが必要
- Python: raw string `r'...'` の使用を推奨
- Go: RE2エンジンで後読みは非サポート

## よくある間違いと対処法

### 1. ドットのエスケープ忘れ

```
間違い: /example.com/  → "exampleXcom" にもマッチ
正解:   /example\.com/
```

### 2. 文字クラス内の特殊文字

```
文字クラス内では多くのメタ文字がリテラル扱い:
[.+*] → ".", "+", "*" のいずれかにマッチ

ただし以下は例外:
] → \] でエスケープ
^ → 先頭以外に置くか \^ でエスケープ
- → 先頭/末尾に置くか \- でエスケープ
\ → \\ でエスケープ
```

### 3. 貪欲マッチの罠

```
入力: "<div>content</div><div>more</div>"
/<div>.*<\/div>/ → 全体にマッチ（貪欲）
/<div>.*?<\/div>/ → 最初の</div>までマッチ（非貪欲）
/<div>[^<]*<\/div>/ → より効率的な方法
```

## 日本語対応

### ひらがな・カタカナ・漢字

```
ひらがな: [\u3040-\u309F]
カタカナ: [\u30A0-\u30FF]
漢字:     [\u4E00-\u9FFF]
全角英数: [Ａ-Ｚａ-ｚ０-９]

// Unicode プロパティ（対応環境のみ）
ひらがな: \p{Script=Hiragana}
カタカナ: \p{Script=Katakana}
漢字:     \p{Script=Han}
```

### 全角・半角の扱い

```
// 全角数字も含める場合
/[0-9０-９]+/

// 電話番号（全角・半角両対応）
/[0-9０-９]{2,4}[-ー][0-9０-９]{2,4}[-ー][0-9０-９]{4}/
```
